from PIL import Image, ImageDraw, ImageFont

def annotate_frame(image_array, radius, elevation, azimuth):
    """
    Annotate image with radius, elevation, and azimuth.
    
    Parameters:
    - image_array (np.array): RGB image.
    - radius (float): Camera radius.
    - elevation (float): Elevation angle in degrees.
    - azimuth (float): Azimuth angle in degrees.
    
    Returns:
    - np.array: Annotated RGB image.
    """
    image = Image.fromarray(image_array)
    draw = ImageDraw.Draw(image)
    text = f"Radius: {radius:.1f} | Elevation: {elevation:.1f}° | Azimuth: {azimuth:.1f}°"
    try:
        font = ImageFont.truetype("DejaVuSans-Bold.ttf", 20)
    except IOError:
        font = ImageFont.load_default()
    draw.text((10, 10), text, font=font, fill=(255, 255, 255))
    return np.array(image)

def render_elevation_video_annotated(path, model, arg_dict, hwf, elevation_start=60, elevation_end=90,
                                     azimuth=180.0, light_angle=(100, 80), n_frames=30, rets=['rgb', 'depth']):
    """
    Render a video showing only a change in elevation from elevation_start to elevation_end,
    with annotations (radius, elevation, azimuth) on each frame.
    """
    frames = {ret: [] for ret in rets}
    az_rad = np.deg2rad(azimuth)
    els = np.deg2rad(np.linspace(elevation_start, elevation_end, n_frames))
    az_light, el_light = [np.deg2rad(a) for a in light_angle]

    H, W, radius = hwf
    for el_rad in els:
        pose = pose_spherical(az_rad, -el_rad, radius)
        view_dir = tf.reshape(tf.convert_to_tensor([az_rad, el_rad], dtype=def_dtype), [1, 2])
        light_dir = tf.reshape(tf.convert_to_tensor([az_light, el_light], dtype=def_dtype), [1, 2])
        ret_dict = render_image(model, arg_dict, hwf, pose, 1.0, light_dirs=light_dir, view_dirs=view_dir, rets=rets)

        el_deg = np.rad2deg(el_rad)
        for ret in rets:
            img = (255 * min_max_normalize(ret_dict[ret].numpy())).astype(np.uint8)
            if ret == 'rgb':
                img = annotate_frame(img, radius, el_deg, azimuth)
            frames[ret].append(img)

    return [render_video(frames[ret], f'{path}elevation_annotated_{ret}.mp4') for ret in rets]



# Exemple d'utilisation
hwf = [H, W, focal]  # à remplacer par les vraies valeurs
render_elevation_video(
    path=arg_dict['out.path'], 
    model=model, 
    arg_dict=arg_dict, 
    hwf=hwf,
    elevation_start=60, 
    elevation_end=90,
    azimuth=180.0,
    light_angle=(100, 80),
    n_frames=30,
    rets=['rgb']
)
