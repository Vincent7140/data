import numpy as np
import tensorflow as tf
import imageio
import matplotlib.pyplot as plt
from io import BytesIO
from data_handling import pose_spherical

def render_views_to_video(model, arg_dict, hwf, azimuths, elevations, radius, zoom_factor=1.0, rets=['rgb'], fps=10, output_path='output_video.mp4'):
    """
    G√©n√®re une vid√©o MP4 √† partir de vues synth√©tiques du mod√®le NeRF, annot√©es avec les angles et le rayon.

    Parameters:
    - model : mod√®le S-NeRF charg√©
    - arg_dict : dictionnaire de configuration
    - hwf : tuple (H, W, focal)
    - azimuths : liste ou array d‚Äôangles azimut (¬∞)
    - elevations : liste ou array d‚Äôangles √©l√©vation (¬∞)
    - radius : rayon utilis√© pour la cam√©ra
    - zoom_factor : facteur de zoom pour le rendu
    - rets : sorties du mod√®le (par d√©faut ['rgb'])
    - fps : images/seconde dans la vid√©o
    - output_path : chemin de sauvegarde du fichier MP4
    """
    frames = []

    for i, (az_deg, el_deg) in enumerate(zip(azimuths, elevations)):
        az = np.deg2rad(az_deg)
        el = np.deg2rad(el_deg)

        pose = pose_spherical(az, el, radius)
        view_dir = tf.reshape(tf.convert_to_tensor([az, el], dtype=tf.float32), [1,2])
        light_dir = tf.reshape(tf.convert_to_tensor([az, el], dtype=tf.float32), [1,2])

        result = render_image(model, arg_dict, hwf, pose, zoom_factor, light_dir, view_dir, rets)
        rgb_image = (255 * result["rgb"].numpy()).astype(np.uint8)

        # Ajout de texte via matplotlib
        fig, ax = plt.subplots(figsize=(6, 6))
        ax.imshow(rgb_image)
        ax.axis('off')
        annotation = f"Az: {az_deg:.1f}¬∞, El: {el_deg:.1f}¬∞, R: {radius:.1f}"
        ax.text(0.98, 0.02, annotation, fontsize=12, color='white',
                ha='right', va='bottom', transform=ax.transAxes,
                bbox=dict(facecolor='black', alpha=0.6, boxstyle='round,pad=0.3'))

        # Sauvegarde temporaire de la figure dans un buffer m√©moire
        buf = BytesIO()
        plt.savefig(buf, format='png')
        buf.seek(0)
        annotated_img = imageio.v3.imread(buf)
        frames.append(annotated_img)
        plt.close(fig)

    # √âcriture vid√©o
    imageio.mimwrite(output_path, frames, fps=fps, quality=8)
    print(f"üé• Vid√©o g√©n√©r√©e : {output_path}")
