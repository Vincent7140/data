import numpy as np
import torch

def rotate_rays_d(rays_d, azimuth_deg=0.0, elevation_deg=0.0):
    """
    Applique une rotation d'azimut (autour de Z) et d'élévation (autour de l'axe horizontal X)
    sur les directions des rayons (rays_d).

    Args:
        rays_d: Tensor (N, 3), vecteurs direction des rayons
        azimuth_deg: angle en degrés (rotation horizontale gauche-droite)
        elevation_deg: angle en degrés (rotation verticale haut-bas)

    Returns:
        rays_d_rotated: Tensor (N, 3), rayons après rotation
    """

    # Conversion en radians
    az = np.radians(azimuth_deg)
    el = np.radians(elevation_deg)

    # Matrice de rotation autour de l'axe Z (azimut)
    Rz = np.array([
        [np.cos(az), -np.sin(az), 0],
        [np.sin(az),  np.cos(az), 0],
        [0, 0, 1]
    ])

    # Matrice de rotation autour de l'axe X (élévation)
    Rx = np.array([
        [1, 0, 0],
        [0, np.cos(el), -np.sin(el)],
        [0, np.sin(el),  np.cos(el)]
    ])

    # Rotation combinée : d'abord Rx puis Rz (ordre important !)
    R = Rz @ Rx

    # Appliquer la rotation
    rays_d_np = rays_d.numpy() if isinstance(rays_d, torch.Tensor) else rays_d
    rays_d_rotated = rays_d_np @ R.T  # (N,3) x (3,3).T

    return torch.from_numpy(rays_d_rotated).float()


# Exemple d'application : tourner la caméra de 20° vers la droite et 10° vers le bas
rays_d_rotated = rotate_rays_d(rays[:, 3:6], azimuth_deg=20, elevation_deg=10)

# Remplace dans tes rayons originaux
rays[:, 3:6] = rays_d_rotated
